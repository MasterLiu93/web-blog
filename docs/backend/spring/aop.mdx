---
sidebar_position: 2
title: "AOP"
description: "Spring面向切面编程原理"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# AOP

AOP（Aspect-Oriented Programming，面向切面编程）是Spring框架的重要特性，它允许开发者将横切关注点（如日志、事务、安全等）从业务逻辑中分离出来。

## AOP原理

### 什么是AOP？

AOP是一种编程范式，它通过预编译方式和运行期动态代理实现程序功能的统一维护。

```java
// 传统方式 - 业务逻辑和横切关注点混合
public class UserService {
    public void createUser(User user) {
        // 日志记录
        System.out.println("开始创建用户: " + user.getName());
        
        // 业务逻辑
        userRepository.save(user);
        
        // 日志记录
        System.out.println("用户创建完成: " + user.getName());
    }
}

// AOP方式 - 分离关注点
@Service
public class UserService {
    public void createUser(User user) {
        // 纯业务逻辑
        userRepository.save(user);
    }
}

@Aspect
@Component
public class LoggingAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("开始执行: " + joinPoint.getSignature().getName());
        Object result = joinPoint.proceed();
        System.out.println("执行完成: " + joinPoint.getSignature().getName());
        return result;
    }
}
```

### AOP的核心概念

```java
// 1. Aspect（切面）- 横切关注点的模块化
@Aspect
@Component
public class LoggingAspect {
    // 切面实现
}

// 2. Join Point（连接点）- 程序执行过程中的某个特定点
// 如方法调用、异常抛出等

// 3. Pointcut（切点）- 匹配连接点的表达式
@Pointcut("execution(* com.example.service.*.*(..))")
public void serviceMethods() {}

// 4. Advice（通知）- 在切点处要执行的代码
@Before("serviceMethods()")
public void beforeAdvice() {
    System.out.println("方法执行前");
}

// 5. Target Object（目标对象）- 被代理的对象
@Service
public class UserService {
    // 目标对象
}

// 6. Proxy（代理）- AOP框架创建的对象
// Spring自动创建代理对象

// 7. Weaving（织入）- 将切面应用到目标对象的过程
```

### AOP的实现原理

```java
// 1. 动态代理实现
public class JdkDynamicProxyExample {
    
    public static void main(String[] args) {
        UserService userService = new UserService();
        
        UserService proxy = (UserService) Proxy.newProxyInstance(
            UserService.class.getClassLoader(),
            new Class[]{UserService.class},
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    // 前置通知
                    System.out.println("方法执行前: " + method.getName());
                    
                    // 执行原方法
                    Object result = method.invoke(userService, args);
                    
                    // 后置通知
                    System.out.println("方法执行后: " + method.getName());
                    
                    return result;
                }
            }
        );
        
        proxy.createUser(new User("张三"));
    }
}

// 2. CGLIB代理实现
public class CglibProxyExample {
    
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                // 前置通知
                System.out.println("方法执行前: " + method.getName());
                
                // 执行原方法
                Object result = proxy.invokeSuper(obj, args);
                
                // 后置通知
                System.out.println("方法执行后: " + method.getName());
                
                return result;
            }
        });
        
        UserService proxy = (UserService) enhancer.create();
        proxy.createUser(new User("李四"));
    }
}
```

## AspectJ注解

### 1. @Aspect - 定义切面

```java
@Aspect
@Component
public class LoggingAspect {
    
    // 切面实现
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() {
        System.out.println("方法执行前记录日志");
    }
}
```

### 2. @Pointcut - 定义切点

```java
@Aspect
@Component
public class LoggingAspect {
    
    // 定义切点
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Pointcut("execution(* com.example.dao.*.*(..))")
    public void daoMethods() {}
    
    @Pointcut("serviceMethods() || daoMethods()")
    public void allMethods() {}
    
    // 使用切点
    @Before("allMethods()")
    public void logBefore() {
        System.out.println("方法执行前记录日志");
    }
}
```

### 3. @Before - 前置通知

```java
@Aspect
@Component
public class LoggingAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void beforeAdvice(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        Object[] args = joinPoint.getArgs();
        
        System.out.println("执行方法: " + className + "." + methodName);
        System.out.println("参数: " + Arrays.toString(args));
    }
}
```

### 4. @After - 后置通知

```java
@Aspect
@Component
public class LoggingAspect {
    
    @After("execution(* com.example.service.*.*(..))")
    public void afterAdvice(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("方法执行完成: " + methodName);
    }
}
```

### 5. @AfterReturning - 返回通知

```java
@Aspect
@Component
public class LoggingAspect {
    
    @AfterReturning(
        pointcut = "execution(* com.example.service.*.*(..))",
        returning = "result"
    )
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("方法 " + methodName + " 返回结果: " + result);
    }
}
```

### 6. @AfterThrowing - 异常通知

```java
@Aspect
@Component
public class LoggingAspect {
    
    @AfterThrowing(
        pointcut = "execution(* com.example.service.*.*(..))",
        throwing = "ex"
    )
    public void afterThrowingAdvice(JoinPoint joinPoint, Throwable ex) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("方法 " + methodName + " 抛出异常: " + ex.getMessage());
    }
}
```

### 7. @Around - 环绕通知

```java
@Aspect
@Component
public class LoggingAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        long startTime = System.currentTimeMillis();
        
        try {
            // 前置处理
            System.out.println("开始执行方法: " + methodName);
            
            // 执行原方法
            Object result = joinPoint.proceed();
            
            // 后置处理
            long endTime = System.currentTimeMillis();
            System.out.println("方法 " + methodName + " 执行完成，耗时: " + (endTime - startTime) + "ms");
            
            return result;
        } catch (Throwable e) {
            // 异常处理
            System.out.println("方法 " + methodName + " 执行异常: " + e.getMessage());
            throw e;
        }
    }
}
```

## AOP应用场景

### 1. 日志记录

```java
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);
    
    @Around("@annotation(com.example.annotation.LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            long endTime = System.currentTimeMillis();
            
            logger.info("方法 {} 执行完成，耗时: {}ms", 
                joinPoint.getSignature().getName(), 
                endTime - startTime);
            
            return result;
        } catch (Exception e) {
            logger.error("方法 {} 执行异常", joinPoint.getSignature().getName(), e);
            throw e;
        }
    }
}

// 自定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {}

// 使用注解
@Service
public class UserService {
    
    @LogExecutionTime
    public void createUser(User user) {
        // 业务逻辑
    }
}
```

### 2. 事务管理

```java
@Aspect
@Component
public class TransactionAspect {
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    @Around("@annotation(com.example.annotation.Transactional)")
    public Object handleTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
        TransactionStatus status = null;
        
        try {
            // 开启事务
            DefaultTransactionDefinition def = new DefaultTransactionDefinition();
            status = transactionManager.getTransaction(def);
            
            // 执行原方法
            Object result = joinPoint.proceed();
            
            // 提交事务
            transactionManager.commit(status);
            
            return result;
        } catch (Exception e) {
            // 回滚事务
            if (status != null) {
                transactionManager.rollback(status);
            }
            throw e;
        }
    }
}

// 自定义事务注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Transactional {}

// 使用注解
@Service
public class OrderService {
    
    @Transactional
    public void createOrder(Order order) {
        // 业务逻辑
    }
}
```

### 3. 权限控制

```java
@Aspect
@Component
public class SecurityAspect {
    
    @Before("@annotation(com.example.annotation.RequirePermission)")
    public void checkPermission(JoinPoint joinPoint) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        RequirePermission annotation = signature.getMethod().getAnnotation(RequirePermission.class);
        String permission = annotation.value();
        
        // 检查用户权限
        if (!hasPermission(getCurrentUser(), permission)) {
            throw new SecurityException("用户没有权限: " + permission);
        }
    }
    
    private boolean hasPermission(User user, String permission) {
        // 权限检查逻辑
        return user.getPermissions().contains(permission);
    }
}

// 权限注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String value();
}

// 使用注解
@Service
public class AdminService {
    
    @RequirePermission("admin:delete")
    public void deleteUser(Long userId) {
        // 删除用户逻辑
    }
}
```

### 4. 缓存管理

```java
@Aspect
@Component
public class CacheAspect {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Around("@annotation(com.example.annotation.Cacheable)")
    public Object handleCache(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Cacheable annotation = signature.getMethod().getAnnotation(Cacheable.class);
        String key = annotation.key();
        
        // 尝试从缓存获取
        Object cachedValue = redisTemplate.opsForValue().get(key);
        if (cachedValue != null) {
            return cachedValue;
        }
        
        // 执行原方法
        Object result = joinPoint.proceed();
        
        // 存入缓存
        redisTemplate.opsForValue().set(key, result, annotation.expire(), TimeUnit.SECONDS);
        
        return result;
    }
}

// 缓存注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Cacheable {
    String key();
    long expire() default 3600;
}

// 使用注解
@Service
public class ProductService {
    
    @Cacheable(key = "product:#{#id}", expire = 1800)
    public Product getProduct(Long id) {
        // 查询产品逻辑
        return productRepository.findById(id);
    }
}
```

### 5. 性能监控

```java
@Aspect
@Component
public class PerformanceAspect {
    
    @Around("execution(* com.example.service.*.*(..))")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        long startTime = System.nanoTime();
        
        try {
            Object result = joinPoint.proceed();
            long endTime = System.nanoTime();
            
            // 记录性能指标
            recordPerformance(methodName, endTime - startTime);
            
            return result;
        } catch (Exception e) {
            // 记录异常
            recordException(methodName, e);
            throw e;
        }
    }
    
    private void recordPerformance(String methodName, long duration) {
        // 记录性能指标到监控系统
        System.out.println("方法 " + methodName + " 执行时间: " + duration + "ns");
    }
    
    private void recordException(String methodName, Exception e) {
        // 记录异常到监控系统
        System.out.println("方法 " + methodName + " 发生异常: " + e.getMessage());
    }
}
```

## AOP性能优化

### 1. 切点表达式优化

```java
@Aspect
@Component
public class OptimizedLoggingAspect {
    
    // 优化前 - 复杂的切点表达式
    @Before("execution(* com.example.service.*.*(..)) && args(user,..)")
    public void logBefore(User user) {
        // 日志记录
    }
    
    // 优化后 - 使用@Pointcut定义可重用的切点
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {}
    
    @Pointcut("args(user,..)")
    public void userParameter(User user) {}
    
    @Pointcut("serviceMethods() && userParameter(user)")
    public void serviceMethodsWithUser(User user) {}
    
    @Before("serviceMethodsWithUser(user)")
    public void logBefore(User user) {
        // 日志记录
    }
}
```

### 2. 代理模式选择

```java
// 1. JDK动态代理 - 适用于接口
@Service
public class UserService implements IUserService {
    // 实现接口的方法
}

// 2. CGLIB代理 - 适用于类
@Service
public class UserService {
    // 不需要实现接口
}

// 配置代理模式
@Configuration
@EnableAspectJAutoProxy(proxyTargetClass = true) // 强制使用CGLIB
public class AopConfig {
    // 配置
}
```

### 3. 切面优先级

```java
@Aspect
@Component
@Order(1) // 高优先级
public class LoggingAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() {
        System.out.println("日志记录");
    }
}

@Aspect
@Component
@Order(2) // 低优先级
public class SecurityAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void checkSecurity() {
        System.out.println("安全检查");
    }
}
```

### 4. 条件切面

```java
@Aspect
@Component
@ConditionalOnProperty(name = "logging.enabled", havingValue = "true")
public class ConditionalLoggingAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() {
        System.out.println("条件日志记录");
    }
}
```

## 面试题

### 1. 什么是AOP？它的优势是什么？

**答案：**
- AOP是面向切面编程，用于将横切关注点从业务逻辑中分离
- 优势：提高代码复用性、降低耦合度、提高可维护性、简化业务逻辑

### 2. Spring AOP和AspectJ有什么区别？

**答案：**
- Spring AOP基于动态代理，只支持方法级别的切面
- AspectJ是完整的AOP框架，支持编译时织入和加载时织入
- Spring AOP性能较好，AspectJ功能更强大

### 3. AOP中的通知类型有哪些？

**答案：**
- @Before：前置通知
- @After：后置通知
- @AfterReturning：返回通知
- @AfterThrowing：异常通知
- @Around：环绕通知

### 4. 如何优化AOP性能？

**答案：**
- 优化切点表达式，使用@Pointcut定义可重用的切点
- 选择合适的代理模式（JDK动态代理或CGLIB）
- 设置切面优先级，避免不必要的切面执行
- 使用条件切面，根据配置决定是否启用

### 5. AOP的常见应用场景有哪些？

**答案：**
- 日志记录
- 事务管理
- 权限控制
- 缓存管理
- 性能监控
- 异常处理
- 数据验证 