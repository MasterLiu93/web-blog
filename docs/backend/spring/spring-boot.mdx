---
sidebar_position: 5
title: "Spring Boot"
description: "Spring Boot框架与自动配置原理"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# Spring Boot

Spring Boot是一个基于Spring框架的快速开发平台，它简化了Spring应用的配置和部署，提供了自动配置、内嵌服务器等特性。

## 自动配置原理

### 什么是自动配置？

Spring Boot的自动配置机制通过`@EnableAutoConfiguration`注解实现，它会根据classpath中的依赖自动配置Spring应用。

```java
// 主启动类
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// @SpringBootApplication注解的组成
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class)
})
public @interface SpringBootApplication {
    // 配置
}
```

### 自动配置的实现原理

```java
// 1. 条件注解机制
@Configuration
@ConditionalOnClass({DataSource.class, EmbeddedDatabaseType.class})
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class})
public class DataSourceAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public DataSource dataSource(DataSourceProperties properties) {
        return properties.initializeDataSourceBuilder().build();
    }
}

// 2. 条件注解类型
@ConditionalOnClass(name = "com.mysql.jdbc.Driver") // 类存在时生效
@ConditionalOnMissingClass("com.mysql.jdbc.Driver") // 类不存在时生效
@ConditionalOnBean(DataSource.class) // Bean存在时生效
@ConditionalOnMissingBean(DataSource.class) // Bean不存在时生效
@ConditionalOnProperty(name = "spring.datasource.type", havingValue = "mysql") // 属性匹配时生效
@ConditionalOnWebApplication // Web应用时生效
@ConditionalOnNotWebApplication // 非Web应用时生效
```

### 自定义自动配置

```java
// 1. 创建配置类
@Configuration
@ConditionalOnClass(MyService.class)
@EnableConfigurationProperties(MyServiceProperties.class)
public class MyServiceAutoConfiguration {
    
    @Autowired
    private MyServiceProperties properties;
    
    @Bean
    @ConditionalOnMissingBean
    public MyService myService() {
        return new MyService(properties.getUrl(), properties.getTimeout());
    }
}

// 2. 创建配置属性类
@ConfigurationProperties(prefix = "my.service")
public class MyServiceProperties {
    
    private String url = "http://localhost:8080";
    private int timeout = 5000;
    
    // getter和setter方法
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    public int getTimeout() {
        return timeout;
    }
    
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }
}

// 3. 创建spring.factories文件
// META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.config.MyServiceAutoConfiguration

// 4. 使用自定义配置
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

## 配置文件

### 1. application.properties

```properties
# 服务器配置
server.port=8080
server.servlet.context-path=/api

# 数据库配置
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.jdbc.Driver

# JPA配置
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5Dialect

# 日志配置
logging.level.root=INFO
logging.level.com.example=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# 自定义配置
my.service.url=http://localhost:8080
my.service.timeout=5000
```

### 2. application.yml

```yaml
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: password
    driver-class-name: com.mysql.jdbc.Driver
  
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL5Dialect
  
  profiles:
    active: dev

logging:
  level:
    root: INFO
    com.example: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

my:
  service:
    url: http://localhost:8080
    timeout: 5000
```

### 3. 多环境配置

```yaml
# application.yml
spring:
  profiles:
    active: dev

---
# application-dev.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test_dev
    username: dev_user
    password: dev_password

logging:
  level:
    com.example: DEBUG

---
# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-server:3306/test_prod
    username: prod_user
    password: prod_password

logging:
  level:
    com.example: WARN
```

### 4. 配置属性绑定

```java
// 1. 使用@Value注解
@Component
public class DatabaseConfig {
    
    @Value("${spring.datasource.url}")
    private String url;
    
    @Value("${spring.datasource.username}")
    private String username;
    
    @Value("${spring.datasource.password}")
    private String password;
    
    @Value("${my.service.timeout:5000}") // 默认值
    private int timeout;
}

// 2. 使用@ConfigurationProperties
@ConfigurationProperties(prefix = "spring.datasource")
@Component
public class DataSourceConfig {
    
    private String url;
    private String username;
    private String password;
    private String driverClassName;
    
    // getter和setter方法
    public String getUrl() {
        return url;
    }
    
    public void setUrl(String url) {
        this.url = url;
    }
    
    // 其他getter和setter方法...
}

// 3. 使用@ConfigurationProperties + @EnableConfigurationProperties
@Configuration
@EnableConfigurationProperties(DataSourceConfig.class)
public class DatabaseAutoConfiguration {
    
    @Bean
    public DataSource dataSource(DataSourceConfig config) {
        return DataSourceBuilder.create()
            .url(config.getUrl())
            .username(config.getUsername())
            .password(config.getPassword())
            .driverClassName(config.getDriverClassName())
            .build();
    }
}
```

## 启动流程

### 1. SpringApplication启动过程

```java
public class SpringApplication {
    
    public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
        return run(new Class<?>[]{primarySource}, args);
    }
    
    public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
        return new SpringApplication(primarySources).run(args);
    }
    
    public ConfigurableApplicationContext run(String... args) {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        ConfigurableApplicationContext context = null;
        Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
        
        configureHeadlessProperty();
        SpringApplicationRunListeners listeners = getRunListeners(args);
        listeners.starting();
        
        try {
            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
            configureIgnoreBeanInfo(environment);
            Banner printedBanner = printBanner(environment);
            context = createApplicationContext();
            exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
                    new Class[]{ConfigurableApplicationContext.class}, context);
            prepareContext(context, environment, listeners, applicationArguments, printedBanner);
            refreshContext(context);
            afterRefresh(context, applicationArguments);
            stopWatch.stop();
            if (this.logStartupInfo) {
                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
            }
            listeners.started(context);
            callRunners(context, applicationArguments);
        } catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, listeners);
            throw new IllegalStateException(ex);
        }
        
        try {
            listeners.running(context);
        } catch (Throwable ex) {
            handleRunFailure(context, ex, exceptionReporters, null);
            throw new IllegalStateException(ex);
        }
        return context;
    }
}
```

### 2. 启动流程详解

```java
// 1. 创建SpringApplication实例
public SpringApplication(Class<?>... primarySources) {
    this(null, primarySources);
}

public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
    this.resourceLoader = resourceLoader;
    Assert.notNull(primarySources, "PrimarySources must not be null");
    this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}

// 2. 准备环境
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
        ApplicationArguments applicationArguments) {
    ConfigurableEnvironment environment = getOrCreateEnvironment();
    configureEnvironment(environment, applicationArguments.getSourceArgs());
    ConfigurationPropertySources.attach(environment);
    listeners.environmentPrepared(environment);
    bindToSpringApplication(environment);
    if (!this.isCustomEnvironment) {
        environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
                deduceEnvironmentClass());
    }
    ConfigurationPropertySources.attach(environment);
    return environment;
}

// 3. 创建ApplicationContext
protected ConfigurableApplicationContext createApplicationContext() {
    Class<?> contextClass = this.applicationContextClass;
    if (contextClass == null) {
        try {
            switch (this.webApplicationType) {
                case SERVLET:
                    return new AnnotationConfigServletWebServerApplicationContext();
                case REACTIVE:
                    return new AnnotationConfigReactiveWebServerApplicationContext();
                default:
                    return new AnnotationConfigApplicationContext();
            }
        } catch (Exception ex) {
            throw new IllegalStateException("Unable create a default ApplicationContext, "
                    + "please specify an ApplicationContextClass", ex);
        }
    }
    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}

// 4. 刷新上下文
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        prepareBeanFactory(beanFactory);
        try {
            postProcessBeanFactory(beanFactory);
            invokeBeanFactoryPostProcessors(beanFactory);
            registerBeanPostProcessors(beanFactory);
            initMessageSource();
            initApplicationEventMulticaster();
            onRefresh();
            registerListeners();
            finishBeanFactoryInitialization(beanFactory);
            finishRefresh();
        } catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization - "
                        + "cancelling refresh attempt: " + ex);
            }
            destroyBeans();
            cancelRefresh(ex);
            throw ex;
        } finally {
            resetCommonCaches();
        }
    }
}
```

### 3. 启动监听器

```java
// 自定义启动监听器
@Component
public class CustomApplicationListener implements ApplicationListener<ApplicationEvent> {
    
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof ApplicationStartingEvent) {
            System.out.println("应用启动中...");
        } else if (event instanceof ApplicationEnvironmentPreparedEvent) {
            System.out.println("环境准备完成...");
        } else if (event instanceof ApplicationContextInitializedEvent) {
            System.out.println("上下文初始化完成...");
        } else if (event instanceof ApplicationPreparedEvent) {
            System.out.println("应用准备完成...");
        } else if (event instanceof ApplicationStartedEvent) {
            System.out.println("应用启动完成...");
        } else if (event instanceof ApplicationReadyEvent) {
            System.out.println("应用就绪...");
        } else if (event instanceof ApplicationFailedEvent) {
            System.out.println("应用启动失败...");
        }
    }
}

// 自定义启动运行器
@Component
public class CustomApplicationRunner implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("应用启动后执行...");
        System.out.println("启动参数: " + Arrays.toString(args.getSourceArgs()));
    }
}

@Component
public class CustomCommandLineRunner implements CommandLineRunner {
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("命令行运行器执行...");
        System.out.println("参数: " + Arrays.toString(args));
    }
}
```

## 监控管理

### 1. Actuator监控

```xml
<!-- 添加Actuator依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yaml
# application.yml配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,env,configprops
      base-path: /actuator
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
```

```java
// 自定义健康检查
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            // 检查数据库连接
            checkDatabase();
            // 检查外部服务
            checkExternalService();
            
            return Health.up()
                .withDetail("database", "UP")
                .withDetail("external-service", "UP")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
    
    private void checkDatabase() {
        // 数据库健康检查逻辑
    }
    
    private void checkExternalService() {
        // 外部服务健康检查逻辑
    }
}

// 自定义指标
@Component
public class CustomMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public CustomMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordCustomMetric(String name, double value) {
        meterRegistry.gauge("custom." + name, value);
    }
    
    public void incrementCounter(String name) {
        meterRegistry.counter("custom." + name).increment();
    }
    
    public Timer.Sample startTimer(String name) {
        return Timer.start(meterRegistry);
    }
}
```

### 2. 自定义监控端点

```java
@RestController
@RequestMapping("/monitor")
public class CustomMonitorController {
    
    @Autowired
    private ApplicationContext applicationContext;
    
    @GetMapping("/beans")
    public List<String> getBeans() {
        return Arrays.asList(applicationContext.getBeanDefinitionNames());
    }
    
    @GetMapping("/env")
    public Map<String, String> getEnvironment() {
        Environment env = applicationContext.getEnvironment();
        Map<String, String> envMap = new HashMap<>();
        
        envMap.put("active.profiles", Arrays.toString(env.getActiveProfiles()));
        envMap.put("default.profiles", Arrays.toString(env.getDefaultProfiles()));
        
        return envMap;
    }
    
    @GetMapping("/memory")
    public Map<String, Object> getMemoryInfo() {
        Runtime runtime = Runtime.getRuntime();
        Map<String, Object> memoryInfo = new HashMap<>();
        
        memoryInfo.put("total.memory", runtime.totalMemory());
        memoryInfo.put("free.memory", runtime.freeMemory());
        memoryInfo.put("used.memory", runtime.totalMemory() - runtime.freeMemory());
        memoryInfo.put("max.memory", runtime.maxMemory());
        
        return memoryInfo;
    }
}
```

### 3. 性能监控

```java
@Aspect
@Component
public class PerformanceMonitorAspect {
    
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitorAspect(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = joinPoint.proceed();
            sample.stop(Timer.builder("http.server.requests")
                .tag("method", methodName)
                .tag("status", "200")
                .register(meterRegistry));
            return result;
        } catch (Exception e) {
            sample.stop(Timer.builder("http.server.requests")
                .tag("method", methodName)
                .tag("status", "500")
                .register(meterRegistry));
            throw e;
        }
    }
}
```

## 面试题

### 1. Spring Boot的自动配置原理是什么？

**答案：**
- 通过`@EnableAutoConfiguration`注解启用自动配置
- 使用条件注解（如`@ConditionalOnClass`）判断是否启用配置
- 通过`spring.factories`文件注册自动配置类
- 根据classpath中的依赖自动配置Spring应用

### 2. Spring Boot的启动流程是怎样的？

**答案：**
1. 创建SpringApplication实例
2. 准备环境（Environment）
3. 创建ApplicationContext
4. 刷新上下文（refresh）
5. 执行ApplicationRunner和CommandLineRunner
6. 启动完成

### 3. 如何自定义Spring Boot的自动配置？

**答案：**
- 创建配置类并使用`@Configuration`注解
- 使用条件注解控制配置的启用条件
- 创建`spring.factories`文件注册自动配置类
- 使用`@EnableConfigurationProperties`绑定配置属性

### 4. Spring Boot的配置文件优先级是怎样的？

**答案：**
1. file:./config/
2. file:./
3. classpath:/config/
4. classpath:/
5. 命令行参数
6. 环境变量

### 5. 如何监控Spring Boot应用？

**答案：**
- 使用Spring Boot Actuator提供监控端点
- 自定义HealthIndicator进行健康检查
- 使用Micrometer收集应用指标
- 集成Prometheus、Grafana等监控工具
- 自定义监控端点和指标 