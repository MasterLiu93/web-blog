---
sidebar_position: 1
title: "IoC容器"
description: "Spring IoC控制反转原理"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# IoC容器

IoC（Inversion of Control，控制反转）是Spring框架的核心概念，它改变了传统的对象创建和依赖管理方式。

## IoC原理

### 什么是IoC？

IoC是一种设计模式，它将原本在程序中手动创建对象的控制权交给Spring容器来管理。

```java
// 传统方式 - 手动创建对象
public class UserService {
    private UserDao userDao;
    
    public UserService() {
        this.userDao = new UserDaoImpl(); // 手动创建依赖
    }
}

// IoC方式 - 由容器管理对象
@Component
public class UserService {
    @Autowired
    private UserDao userDao; // 由Spring容器注入依赖
}
```

### IoC容器的核心组件

```java
// 1. BeanDefinition - 描述Bean的元数据
public class BeanDefinition {
    private String beanClassName;
    private Class<?> beanClass;
    private String scope;
    private boolean lazyInit;
    private String[] dependsOn;
    private String initMethodName;
    private String destroyMethodName;
    // ... 其他属性
}

// 2. BeanFactory - IoC容器的基本实现
public interface BeanFactory {
    Object getBean(String name);
    <T> T getBean(Class<T> requiredType);
    <T> T getBean(String name, Class<T> requiredType);
    boolean containsBean(String name);
    boolean isSingleton(String name);
    boolean isPrototype(String name);
}

// 3. ApplicationContext - 更高级的IoC容器
public interface ApplicationContext extends BeanFactory {
    String getApplicationName();
    ApplicationContext getParent();
    AutowireCapableBeanFactory getAutowireCapableBeanFactory();
    // ... 其他方法
}
```

### IoC容器的实现原理

```java
public class SimpleIoCContainer {
    private Map<String, Object> beans = new HashMap<>();
    private Map<String, BeanDefinition> beanDefinitions = new HashMap<>();
    
    // 注册Bean定义
    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) {
        beanDefinitions.put(beanName, beanDefinition);
    }
    
    // 获取Bean
    public Object getBean(String beanName) {
        Object bean = beans.get(beanName);
        if (bean != null) {
            return bean;
        }
        
        // 创建Bean
        bean = createBean(beanName);
        beans.put(beanName, bean);
        return bean;
    }
    
    // 创建Bean实例
    private Object createBean(String beanName) {
        BeanDefinition beanDefinition = beanDefinitions.get(beanName);
        if (beanDefinition == null) {
            throw new RuntimeException("Bean not found: " + beanName);
        }
        
        try {
            // 1. 实例化
            Object bean = beanDefinition.getBeanClass().newInstance();
            
            // 2. 属性注入
            injectProperties(bean, beanDefinition);
            
            // 3. 初始化
            if (beanDefinition.getInitMethodName() != null) {
                Method initMethod = bean.getClass().getMethod(beanDefinition.getInitMethodName());
                initMethod.invoke(bean);
            }
            
            return bean;
        } catch (Exception e) {
            throw new RuntimeException("Error creating bean: " + beanName, e);
        }
    }
    
    // 属性注入
    private void injectProperties(Object bean, BeanDefinition beanDefinition) {
        // 实现依赖注入逻辑
    }
}
```

## Bean生命周期

### Bean的完整生命周期

```java
@Component
public class LifecycleBean implements InitializingBean, DisposableBean {
    
    private String name;
    
    // 1. 构造方法
    public LifecycleBean() {
        System.out.println("1. 构造方法执行");
    }
    
    // 2. 属性注入
    @Autowired
    public void setDependency(SomeService someService) {
        System.out.println("2. 属性注入");
    }
    
    // 3. BeanNameAware
    @Override
    public void setBeanName(String name) {
        System.out.println("3. BeanNameAware: " + name);
    }
    
    // 4. BeanFactoryAware
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println("4. BeanFactoryAware");
    }
    
    // 5. ApplicationContextAware
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        System.out.println("5. ApplicationContextAware");
    }
    
    // 6. BeanPostProcessor前置处理
    // 7. @PostConstruct
    @PostConstruct
    public void postConstruct() {
        System.out.println("7. @PostConstruct");
    }
    
    // 8. InitializingBean
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("8. InitializingBean.afterPropertiesSet()");
    }
    
    // 9. 自定义初始化方法
    public void customInit() {
        System.out.println("9. 自定义初始化方法");
    }
    
    // 10. BeanPostProcessor后置处理
    
    // 11. Bean使用阶段
    
    // 12. @PreDestroy
    @PreDestroy
    public void preDestroy() {
        System.out.println("12. @PreDestroy");
    }
    
    // 13. DisposableBean
    @Override
    public void destroy() throws Exception {
        System.out.println("13. DisposableBean.destroy()");
    }
    
    // 14. 自定义销毁方法
    public void customDestroy() {
        System.out.println("14. 自定义销毁方法");
    }
}
```

### BeanPostProcessor示例

```java
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("BeanPostProcessor前置处理: " + beanName);
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("BeanPostProcessor后置处理: " + beanName);
        return bean;
    }
}
```

## 依赖注入

### 1. 构造器注入

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // 构造器注入
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public void createUser(User user) {
        userRepository.save(user);
        emailService.sendWelcomeEmail(user.getEmail());
    }
}
```

### 2. Setter注入

```java
@Service
public class OrderService {
    private PaymentService paymentService;
    private NotificationService notificationService;
    
    // Setter注入
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    @Autowired
    public void setNotificationService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}
```

### 3. 字段注入

```java
@Service
public class ProductService {
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    public void updateProduct(Product product) {
        productRepository.save(product);
        inventoryService.updateStock(product.getId(), product.getQuantity());
    }
}
```

### 4. 接口注入

```java
public interface ServiceLocator {
    <T> T getService(Class<T> serviceType);
}

@Component
public class ServiceLocatorImpl implements ServiceLocator {
    @Autowired
    private ApplicationContext applicationContext;
    
    @Override
    public <T> T getService(Class<T> serviceType) {
        return applicationContext.getBean(serviceType);
    }
}
```

### 5. 条件注入

```java
@Configuration
public class DatabaseConfig {
    
    @Bean
    @ConditionalOnProperty(name = "database.type", havingValue = "mysql")
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }
    
    @Bean
    @ConditionalOnProperty(name = "database.type", havingValue = "postgresql")
    public DataSource postgresqlDataSource() {
        return new PostgresqlDataSource();
    }
    
    @Bean
    @ConditionalOnClass(name = "com.mysql.jdbc.Driver")
    public DataSource autoDetectedDataSource() {
        return new AutoDetectedDataSource();
    }
}
```

## Bean作用域

### 1. Singleton（单例）

```java
@Component
@Scope("singleton") // 默认作用域
public class SingletonBean {
    private int counter = 0;
    
    public void increment() {
        counter++;
    }
    
    public int getCounter() {
        return counter;
    }
}
```

### 2. Prototype（原型）

```java
@Component
@Scope("prototype")
public class PrototypeBean {
    private int counter = 0;
    
    public void increment() {
        counter++;
    }
    
    public int getCounter() {
        return counter;
    }
}
```

### 3. Request作用域

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean {
    private String requestId;
    
    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }
    
    public String getRequestId() {
        return requestId;
    }
}
```

### 4. Session作用域

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionScopedBean {
    private String sessionId;
    private List<String> userActions = new ArrayList<>();
    
    public void addAction(String action) {
        userActions.add(action);
    }
    
    public List<String> getUserActions() {
        return userActions;
    }
}
```

### 5. 自定义作用域

```java
public class ThreadScope implements Scope {
    private final ThreadLocal<Map<String, Object>> threadLocal = new ThreadLocal<>();
    
    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Map<String, Object> scope = threadLocal.get();
        if (scope == null) {
            scope = new HashMap<>();
            threadLocal.set(scope);
        }
        
        Object object = scope.get(name);
        if (object == null) {
            object = objectFactory.getObject();
            scope.put(name, object);
        }
        
        return object;
    }
    
    @Override
    public Object remove(String name) {
        Map<String, Object> scope = threadLocal.get();
        if (scope != null) {
            return scope.remove(name);
        }
        return null;
    }
    
    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        // 实现销毁回调
    }
    
    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }
    
    @Override
    public String getConversationId() {
        return Thread.currentThread().getName();
    }
}

// 注册自定义作用域
@Configuration
public class CustomScopeConfig {
    
    @Bean
    public static CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer configurer = new CustomScopeConfigurer();
        configurer.addScope("thread", new ThreadScope());
        return configurer;
    }
}
```

## 高级特性

### 1. 循环依赖处理

```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
    
    public void methodA() {
        System.out.println("ServiceA.methodA()");
        serviceB.methodB();
    }
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
    
    public void methodB() {
        System.out.println("ServiceB.methodB()");
    }
}
```

### 2. 懒加载

```java
@Component
@Lazy
public class LazyBean {
    
    public LazyBean() {
        System.out.println("LazyBean被创建");
    }
    
    public void doSomething() {
        System.out.println("LazyBean执行操作");
    }
}
```

### 3. 条件Bean

```java
@Configuration
public class ConditionalConfig {
    
    @Bean
    @ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
    public FeatureService featureService() {
        return new FeatureService();
    }
    
    @Bean
    @ConditionalOnClass(name = "org.springframework.boot.autoconfigure.EnableAutoConfiguration")
    public AutoConfigurationService autoConfigurationService() {
        return new AutoConfigurationService();
    }
    
    @Bean
    @ConditionalOnMissingBean
    public DefaultService defaultService() {
        return new DefaultService();
    }
}
```

## 面试题

### 1. 什么是IoC？它的优势是什么？

**答案：**
- IoC是控制反转，将对象创建和依赖管理的控制权交给容器
- 优势：降低耦合度、提高可测试性、简化对象管理、支持配置化

### 2. Spring IoC容器的启动过程是怎样的？

**答案：**
1. 加载配置文件
2. 解析Bean定义
3. 注册BeanDefinition
4. 实例化Bean
5. 依赖注入
6. 初始化Bean
7. 注册销毁回调

### 3. Bean的生命周期包括哪些阶段？

**答案：**
1. 实例化
2. 属性注入
3. Aware接口回调
4. BeanPostProcessor前置处理
5. 初始化方法
6. BeanPostProcessor后置处理
7. 使用阶段
8. 销毁方法

### 4. 如何解决循环依赖？

**答案：**
- Spring通过三级缓存解决循环依赖
- 一级缓存：完全初始化好的Bean
- 二级缓存：早期暴露的Bean
- 三级缓存：Bean工厂

### 5. @Autowired和@Resource有什么区别？

**答案：**
- @Autowired是Spring注解，默认按类型注入
- @Resource是JSR-250注解，默认按名称注入
- @Autowired可以设置required属性
- @Resource可以指定name和type属性 