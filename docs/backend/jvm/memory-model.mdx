---
sidebar_position: 1
title: "JVM内存模型"
description: "Java虚拟机内存结构详解"
authors: [Laby]
last_update:
  date: 2023-08-07
  author: Laby
---

# JVM内存模型

Java虚拟机(JVM)内存模型是Java程序运行的基础架构，它定义了Java程序如何与计算机内存交互，并在并发环境下保证内存操作的可见性、原子性和有序性。深入理解JVM内存模型对于编写高效、安全的Java应用程序至关重要。

## 运行时数据区

JVM运行时数据区分为五个主要部分，其中堆和方法区是所有线程共享的，而虚拟机栈、本地方法栈和程序计数器则是线程私有的。

### 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

- **作用**：记录正在执行的虚拟机字节码指令的地址
- **特点**：
  - 线程私有，每个线程都有自己的程序计数器
  - 是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域
- **执行过程**：
  - 如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址
  - 如果执行的是Native方法，计数器值为空（Undefined）

### Java虚拟机栈（JVM Stack）

Java虚拟机栈描述的是Java方法执行的线程内存模型。

- **结构**：每个方法被执行时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接和方法出口等信息
- **特点**：
  - 线程私有，生命周期与线程相同
  - 栈容量可以是固定的，也可以是动态扩展的
- **异常**：
  - 当线程请求的栈深度大于虚拟机允许的深度时，会抛出StackOverflowError
  - 如果栈可以动态扩展但无法申请到足够内存，会抛出OutOfMemoryError

### 本地方法栈（Native Method Stack）

本地方法栈与Java虚拟机栈类似，但它为JVM使用到的Native方法服务。

- **作用**：为虚拟机执行本地方法（通常使用C/C++编写）提供内存空间
- **实现**：具体实现由JVM厂商自由实现，HotSpot虚拟机将本地方法栈和Java虚拟机栈合二为一

### 堆（Heap）

Java堆是JVM管理的最大内存区域，所有对象实例和数组都在堆上分配。

- **特点**：
  - 被所有线程共享
  - 在虚拟机启动时创建
  - 唯一目的就是存放对象实例
  - 是垃圾收集器管理的主要区域，也称为"GC堆"
- **结构**：
  - 新生代（Young Generation）：Eden空间、From Survivor、To Survivor
  - 老年代（Old Generation）：存放长期存活的对象
  - 永久代（JDK 8之前）/元空间（JDK 8及之后，使用本地内存）
- **内存分配**：
  - 指针碰撞（Bump the Pointer）：适用于规整的内存空间
  - 空闲列表（Free List）：适用于不规整的内存空间

### 方法区（Method Area）

方法区用于存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

- **特点**：
  - 被所有线程共享
  - JDK 8之前，方法区也被称为"永久代"（PermGen）
  - JDK 8及之后，取消了永久代，改用本地内存实现的元空间（Metaspace）
- **内容**：
  - 类信息（版本、字段、方法、接口等）
  - 常量池
  - 静态变量
  - 即时编译器编译后的代码缓存

### 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

- **作用**：存储编译期生成的字面量和符号引用
- **特点**：具有动态性，可以在运行期间将新的常量放入池中（如String.intern()方法）

## 对象创建过程

Java对象的创建过程涉及多个步骤，从类加载到对象初始化。

### 1. 类加载检查

当JVM遇到一条`new`指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，需要先执行相应的类加载过程。

### 2. 分配内存

在类加载检查通过后，JVM为新生对象分配内存。对象所需内存大小在类加载完成后即可确定。分配方式有两种：

- **指针碰撞（Bump the Pointer）**：适用于内存规整的情况（使用复制算法或标记-整理算法的垃圾收集器）
- **空闲列表（Free List）**：适用于内存不规整的情况（使用标记-清除算法的垃圾收集器）

### 3. 解决并发安全问题

在多线程环境下，内存分配需要保证线程安全。主要有两种方式：

- **CAS（Compare And Swap）+失败重试**：乐观锁方式
- **TLAB（Thread Local Allocation Buffer）**：为每个线程预先分配一块内存，称为本地线程分配缓冲区

### 4. 初始化零值

内存分配完成后，JVM将分配到的内存空间都初始化为零值（不包括对象头），保证对象的实例字段在Java代码中可以不赋初始值就直接使用。

### 5. 设置对象头

JVM对对象进行必要的设置，如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存储在对象的对象头中。

### 6. 执行init方法

从JVM角度看，对象已经产生了。但从Java程序角度，对象创建才刚开始，还需要执行`<init>`方法（即构造方法），按照程序员的意愿进行初始化。

## 对象引用类型

Java提供了四种引用类型，用于灵活控制对象的生命周期。

### 强引用（Strong Reference）

最常见的引用类型，只要强引用存在，垃圾收集器永远不会回收被引用的对象。

```java
Object obj = new Object(); // 强引用
```

### 软引用（Soft Reference）

用于描述还有用但非必需的对象。在系统将要发生内存溢出前，会将这些对象列入回收范围进行第二次回收。

```java
SoftReference<Object> softRef = new SoftReference<>(obj);
```

### 弱引用（Weak Reference）

比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当GC工作时，无论内存是否足够，都会回收被弱引用关联的对象。

```java
WeakReference<Object> weakRef = new WeakReference<>(obj);
```

### 虚引用（Phantom Reference）

最弱的引用关系，几乎不对对象的生存时间构成影响，也无法通过虚引用获取对象实例。设置虚引用的唯一目的是能在这个对象被垃圾收集器回收时收到一个系统通知。

```java
PhantomReference<Object> phantomRef = new PhantomReference<>(obj, referenceQueue);
```

## 内存分配策略

JVM在对象内存分配过程中使用了多种策略，以提高分配效率和垃圾收集效率。

### 对象优先在Eden分配

大多数情况下，对象优先在新生代的Eden区分配。当Eden区没有足够空间时，JVM将发起一次Minor GC。

### 大对象直接进入老年代

大对象是指需要大量连续内存空间的对象，如长字符串或数组。为避免在Eden和Survivor区之间复制大对象，JVM会将这些对象直接分配到老年代。

### 长期存活的对象进入老年代

JVM给每个对象定义了一个对象年龄（Age）计数器。对象每经过一次Minor GC且仍然存活，年龄就增加1。当年龄增加到一定程度（默认为15），就会被晋升到老年代。

### 动态对象年龄判定

JVM不会永远等到对象年龄达到阈值才晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

### 空间分配担保

在发生Minor GC之前，JVM会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果条件成立，Minor GC可以确保安全。否则，JVM会查看HandlePromotionFailure设置是否允许担保失败：
- 如果允许，会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小
- 如果不允许，或者上述条件不成立，则改为进行一次Full GC

## JVM内存模型总结

JVM内存模型是Java运行时环境的基础架构，它定义了Java程序的内存组织方式和操作规则。主要包括线程私有的程序计数器、虚拟机栈和本地方法栈，以及线程共享的堆和方法区。对象创建涉及类加载检查、内存分配、对象初始化等步骤，而内存分配策略则根据对象特性决定其存储位置。

理解JVM内存模型有助于我们编写高效的代码、诊断内存问题、优化应用性能，以及在并发环境中正确处理共享数据。特别是在处理高并发、大数据量的应用时，对内存模型的深入理解能够帮助我们避免内存泄漏、栈溢出和内存不足等常见问题。

## 面试题

### 1. 请描述JVM的内存区域划分，及每个区域的作用？

**答**：JVM内存区域主要分为以下几个部分：

1. **程序计数器**：线程私有，记录当前线程执行的字节码指令地址，是唯一不会发生OutOfMemoryError的区域
2. **虚拟机栈**：线程私有，存储局部变量表、操作数栈、动态链接和方法出口等信息，可能发生StackOverflowError和OutOfMemoryError
3. **本地方法栈**：线程私有，为Native方法服务，具体实现由JVM厂商决定
4. **堆**：线程共享，存放对象实例和数组，是垃圾收集器管理的主要区域，可能发生OutOfMemoryError
5. **方法区**：线程共享，存储已加载的类信息、常量、静态变量等，在JDK8之前称为永久代，JDK8后称为元空间并使用本地内存

### 2. Java对象的创建过程是怎样的？

**答**：Java对象的创建过程包括以下步骤：

1. **类加载检查**：检查类是否已加载、解析和初始化
2. **分配内存**：根据对象大小在堆中分配内存，方式有指针碰撞和空闲列表两种
3. **解决并发安全问题**：通过CAS+失败重试或TLAB（线程本地分配缓冲区）保证线程安全
4. **初始化零值**：将分配的内存空间初始化为零值
5. **设置对象头**：包括存储对象的类型指针、哈希码、GC分代年龄等信息
6. **执行init方法**：调用对象的构造方法，完成对象的初始化

### 3. 什么是TLAB，它解决了什么问题？

**答**：TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）是JVM在堆中为每个线程预先分配的一小块内存。

- **解决问题**：主要解决多线程环境下内存分配的线程安全问题。如果没有TLAB，多个线程同时分配内存时需要同步操作，会导致性能下降。
- **工作原理**：每个线程在堆中拥有自己的TLAB，线程首先尝试在自己的TLAB中分配对象，只有当TLAB空间不足时，才会通过加锁机制在堆的公共部分分配。
- **优势**：大多数对象分配都可以在TLAB中完成，避免了同步操作，提高了分配效率。

### 4. Java中的四种引用类型及其应用场景是什么？

**答**：Java中的四种引用类型及其应用场景：

1. **强引用（Strong Reference）**：
   - 特点：只要强引用存在，对象就不会被回收
   - 应用场景：常规对象引用，大部分业务逻辑中使用

2. **软引用（Soft Reference）**：
   - 特点：内存不足时才会被回收
   - 应用场景：缓存实现，如图片缓存、网页缓存等，当内存不足时可以释放

3. **弱引用（Weak Reference）**：
   - 特点：下一次GC时无论内存是否充足都会回收
   - 应用场景：WeakHashMap实现，ThreadLocal中的Entry，避免内存泄漏

4. **虚引用（Phantom Reference）**：
   - 特点：不影响对象生命周期，必须与ReferenceQueue配合使用
   - 应用场景：跟踪对象被垃圾回收的状态，如NIO中的DirectByteBuffer对象回收

### 5. 对象在内存中的分配策略有哪些？

**答**：对象在内存中的分配策略：

1. **对象优先在Eden区分配**：新创建的对象首先分配在Eden区。当Eden区满时，触发Minor GC，将存活对象移到Survivor区。

2. **大对象直接进入老年代**：需要大量连续内存空间的对象（如长数组）会直接分配到老年代，避免在Eden和Survivor区频繁复制造成的效率问题。

3. **长期存活的对象进入老年代**：对象在Survivor区每熬过一次Minor GC，年龄加1，当达到阈值（默认15）时，晋升到老年代。

4. **动态对象年龄判定**：如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间一半，年龄大于或等于该年龄的对象可以直接进入老年代。

5. **空间分配担保**：Minor GC前，检查老年代最大可用连续空间是否大于新生代所有对象总空间或历次晋升的平均大小，以确定是否需要提前触发Full GC。

### 6. 栈上分配和逃逸分析是什么？有什么作用？

**答**：栈上分配和逃逸分析是JVM的优化技术：

**逃逸分析**：
- 定义：分析对象的动态作用域，判断对象是否逃逸出方法或线程的范围
- 原理：如果对象仅在方法内部使用，没有逃逸出方法的作用域，则可以进行优化

**栈上分配**：
- 定义：基于逃逸分析的结果，将不会逃逸的对象直接在栈上分配内存
- 优势：
  1. 对象随栈帧的创建和销毁自动管理，无需GC介入
  2. 访问速度更快，因为在栈上
  3. 减少堆内存压力，降低GC频率

**其他基于逃逸分析的优化**：
1. **锁消除**：如果对象不会被多个线程访问，可以去除同步操作
2. **标量替换**：将对象分解成基本类型数据直接在栈上操作，无需创建对象

### 7. 如何理解JMM（Java内存模型）中的happen-before原则？

**答**：happen-before是Java内存模型中的重要概念，用于定义多线程环境中操作之间的可见性关系。如果操作A happen-before操作B，则A的结果对B可见。

主要的happen-before规则包括：

1. **程序顺序规则**：单线程中，按照程序顺序，前面的操作happen-before后面的操作
2. **监视器锁规则**：解锁操作happen-before后续的加锁操作
3. **volatile变量规则**：对volatile变量的写操作happen-before后续对该变量的读操作
4. **传递性**：如果A happen-before B，且B happen-before C，则A happen-before C
5. **线程启动规则**：Thread.start()操作happen-before线程中的任何操作
6. **线程终止规则**：线程中的所有操作happen-before其他线程中的Thread.join()操作
7. **中断规则**：调用Thread.interrupt()happen-before被中断线程检测到中断
8. **构造器规则**：对象的构造函数执行完成happen-before其finalize()方法开始

这些规则确保了在没有明确同步的情况下，多线程环境中哪些操作可以保证对其他线程可见，是编写并发程序的重要基础。

### 8. 对象的内存布局是怎样的？

**答**：在HotSpot虚拟机中，对象的内存布局分为三个部分：

1. **对象头（Header）**：
   - **Mark Word**：包含哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等信息，在32位和64位虚拟机中分别占用32bit和64bit
   - **类型指针**：指向对象的类元数据的指针，通过这个指针确定对象是哪个类的实例
   - **数组长度**（仅数组对象有）：如果对象是数组，还需要记录数组长度的信息

2. **实例数据（Instance Data）**：
   - 存储对象的实际数据，即各个字段的内容
   - 相同宽度的字段会被分配在一起，满足对齐要求
   - 继承的字段通常会在子类字段之前，父类中定义的变量会出现在子类之前

3. **对齐填充（Padding）**：
   - 不是必须的，仅用于确保对象的大小满足8字节的整数倍
   - 对齐填充是为了满足JVM对象分配时的内存对齐要求，提高访问效率

### 9. 什么情况下会发生栈溢出和堆溢出？如何避免？

**答**：栈溢出和堆溢出的情况及避免方法：

**栈溢出（StackOverflowError）**：
- **发生原因**：
  1. 方法递归调用层次过深
  2. 方法内部大量创建局部变量
- **避免方法**：
  1. 优化递归算法，使用迭代替代递归
  2. 增加栈内存大小（使用-Xss参数）
  3. 控制递归深度，在可能发生溢出前返回

**堆溢出（OutOfMemoryError: Java heap space）**：
- **发生原因**：
  1. 创建了大量对象且无法被GC回收
  2. 内存泄漏（对象不再使用但仍被引用）
  3. 单个对象过大
- **避免方法**：
  1. 增加堆内存大小（使用-Xmx参数）
  2. 检查并修复内存泄漏（使用工具如JProfiler, MAT）
  3. 优化对象使用，及时释放不用的对象引用
  4. 使用内存池复用对象，减少对象创建

### 10. 什么是方法区溢出？在JDK8前后有何不同？

**答**：方法区溢出是指方法区空间不足导致的OutOfMemoryError。

**JDK8之前（使用永久代）**：
- 异常信息：`java.lang.OutOfMemoryError: PermGen space`
- 发生原因：
  1. 加载了大量类（如使用反射、动态代理、CGLib等）
  2. JSP应用重新部署时大量类被加载
  3. 第三方框架（如Spring、Hibernate）创建大量动态类
- 调整方式：使用`-XX:PermSize`和`-XX:MaxPermSize`参数设置永久代大小

**JDK8及之后（使用元空间）**：
- 异常信息：`java.lang.OutOfMemoryError: Metaspace`
- 特点：元空间使用本地内存，不再受JVM堆大小限制
- 发生原因：与之前类似，但因为默认不限制元空间大小，所以更可能引起系统内存溢出
- 调整方式：使用`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`参数限制元空间大小

**避免方法区溢出的措施**：
1. 控制动态类的生成和加载
2. 定期清理不再使用的类加载器
3. 使用字节码精简工具减小类大小
4. 合理设置方法区大小参数 