---
sidebar_position: 6
title: "并发容器"
description: "Java并发容器详解"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# 并发容器

Java并发包提供了多种线程安全的容器类，这些容器专门为多线程环境设计，提供了比使用synchronized更高效的并发访问机制。

## ConcurrentHashMap

ConcurrentHashMap是HashMap的线程安全版本，使用分段锁机制实现高并发。

### 基本用法

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConcurrentHashMapExample {
    
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // 多个线程同时写入
        for (int i = 0; i < 3; i++) {
            final int threadId = i;
            executor.submit(() -> {
                for (int j = 0; j < 10; j++) {
                    String key = "key-" + threadId + "-" + j;
                    map.put(key, j);
                    System.out.println("线程 " + threadId + " 写入: " + key);
                }
            });
        }
        
        executor.shutdown();
        
        // 等待所有线程完成
        while (!executor.isTerminated()) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        System.out.println("最终Map大小: " + map.size());
        System.out.println("Map内容: " + map);
    }
}
```

### 原子操作

```java
public class ConcurrentHashMapAtomicOps {
    
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // putIfAbsent - 如果key不存在才放入
        map.putIfAbsent("key1", 1);
        map.putIfAbsent("key1", 2); // 不会覆盖，因为key1已存在
        System.out.println("putIfAbsent结果: " + map.get("key1")); // 1
        
        // replace - 替换值
        map.replace("key1", 1, 10); // 只有当值为1时才替换为10
        System.out.println("replace结果: " + map.get("key1")); // 10
        
        // compute - 计算新值
        map.compute("key2", (key, value) -> {
            return value == null ? 1 : value + 1;
        });
        System.out.println("compute结果: " + map.get("key2")); // 1
        
        // computeIfAbsent - 如果key不存在才计算
        map.computeIfAbsent("key3", key -> key.length());
        System.out.println("computeIfAbsent结果: " + map.get("key3")); // 4
        
        // computeIfPresent - 如果key存在才计算
        map.computeIfPresent("key3", (key, value) -> value * 2);
        System.out.println("computeIfPresent结果: " + map.get("key3")); // 8
        
        // merge - 合并值
        map.merge("key4", 1, (oldValue, newValue) -> oldValue + newValue);
        map.merge("key4", 2, (oldValue, newValue) -> oldValue + newValue);
        System.out.println("merge结果: " + map.get("key4")); // 3
    }
}
```

### 批量操作

```java
public class ConcurrentHashMapBatchOps {
    
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // 初始化数据
        for (int i = 0; i < 10; i++) {
            map.put("key" + i, i);
        }
        
        // forEach - 遍历所有元素
        System.out.println("遍历所有元素:");
        map.forEach((key, value) -> System.out.println(key + " = " + value));
        
        // forEachKey - 只遍历key
        System.out.println("\n遍历所有key:");
        map.forEachKey(1, key -> System.out.println("Key: " + key));
        
        // forEachValue - 只遍历value
        System.out.println("\n遍历所有value:");
        map.forEachValue(1, value -> System.out.println("Value: " + value));
        
        // forEachEntry - 遍历entry
        System.out.println("\n遍历所有entry:");
        map.forEachEntry(1, entry -> 
            System.out.println(entry.getKey() + " = " + entry.getValue()));
        
        // reduce - 归约操作
        int sum = map.reduce(1, 
            (key, value) -> value, 
            Integer::sum);
        System.out.println("\n所有值的和: " + sum);
    }
}
```

## CopyOnWriteArrayList

CopyOnWriteArrayList是ArrayList的线程安全版本，适用于读多写少的场景。

### 基本用法

```java
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CopyOnWriteArrayListExample {
    
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // 添加初始元素
        list.add("初始元素1");
        list.add("初始元素2");
        
        // 多个线程同时读写
        for (int i = 0; i < 3; i++) {
            final int threadId = i;
            executor.submit(() -> {
                // 写操作
                list.add("线程" + threadId + "添加的元素");
                
                // 读操作
                for (String item : list) {
                    System.out.println("线程" + threadId + "读取: " + item);
                }
            });
        }
        
        executor.shutdown();
        
        System.out.println("最终列表大小: " + list.size());
        System.out.println("最终列表内容: " + list);
    }
}
```

### 适用场景

```java
public class CopyOnWriteArrayListUseCase {
    
    private final CopyOnWriteArrayList<EventListener> listeners = 
        new CopyOnWriteArrayList<>();
    
    // 添加监听器（写操作较少）
    public void addEventListener(EventListener listener) {
        listeners.add(listener);
    }
    
    // 移除监听器（写操作较少）
    public void removeEventListener(EventListener listener) {
        listeners.remove(listener);
    }
    
    // 通知所有监听器（读操作较多）
    public void notifyListeners(String event) {
        for (EventListener listener : listeners) {
            try {
                listener.onEvent(event);
            } catch (Exception e) {
                // 处理异常
            }
        }
    }
    
    interface EventListener {
        void onEvent(String event);
    }
}
```

## BlockingQueue

BlockingQueue是一个阻塞队列接口，提供了线程安全的队列操作。

### ArrayBlockingQueue

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ArrayBlockingQueueExample {
    
    public static void main(String[] args) {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // 生产者
        executor.submit(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    String item = "Item-" + i;
                    queue.put(item); // 阻塞直到有空间
                    System.out.println("生产者放入: " + item);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // 消费者
        executor.submit(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    String item = queue.take(); // 阻塞直到有元素
                    System.out.println("消费者取出: " + item);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        executor.shutdown();
    }
}
```

### LinkedBlockingQueue

```java
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class LinkedBlockingQueueExample {
    
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(3);
        
        // 生产者
        new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    boolean offered = queue.offer(i, 1, TimeUnit.SECONDS);
                    if (offered) {
                        System.out.println("成功放入: " + i);
                    } else {
                        System.out.println("放入超时: " + i);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // 消费者
        new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    Integer item = queue.poll(2, TimeUnit.SECONDS);
                    if (item != null) {
                        System.out.println("成功取出: " + item);
                    } else {
                        System.out.println("取出超时");
                    }
                    Thread.sleep(1500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

### PriorityBlockingQueue

```java
import java.util.concurrent.PriorityBlockingQueue;

public class PriorityBlockingQueueExample {
    
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new PriorityBlockingQueue<>();
        
        // 生产者
        new Thread(() -> {
            try {
                int[] numbers = {5, 2, 8, 1, 9, 3};
                for (int num : numbers) {
                    queue.put(num);
                    System.out.println("放入: " + num);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
        
        // 消费者
        new Thread(() -> {
            try {
                for (int i = 0; i < 6; i++) {
                    Integer item = queue.take();
                    System.out.println("取出: " + item);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

## ConcurrentLinkedQueue

ConcurrentLinkedQueue是一个无界线程安全的队列，基于链表实现。

```java
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConcurrentLinkedQueueExample {
    
    public static void main(String[] args) {
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        // 多个生产者
        for (int i = 0; i < 2; i++) {
            final int producerId = i;
            executor.submit(() -> {
                for (int j = 0; j < 5; j++) {
                    String item = "Producer" + producerId + "-Item" + j;
                    queue.offer(item);
                    System.out.println("生产者" + producerId + "放入: " + item);
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        
        // 多个消费者
        for (int i = 0; i < 2; i++) {
            final int consumerId = i;
            executor.submit(() -> {
                for (int j = 0; j < 5; j++) {
                    String item = queue.poll();
                    if (item != null) {
                        System.out.println("消费者" + consumerId + "取出: " + item);
                    }
                    try {
                        Thread.sleep(300);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        
        executor.shutdown();
    }
}
```

## 其他并发容器

### ConcurrentSkipListMap

```java
import java.util.concurrent.ConcurrentSkipListMap;

public class ConcurrentSkipListMapExample {
    
    public static void main(String[] args) {
        ConcurrentSkipListMap<String, Integer> map = new ConcurrentSkipListMap<>();
        
        // 添加元素（自动排序）
        map.put("zebra", 1);
        map.put("apple", 2);
        map.put("banana", 3);
        map.put("cat", 4);
        
        System.out.println("排序后的Map:");
        map.forEach((key, value) -> System.out.println(key + " = " + value));
        
        // 获取第一个和最后一个元素
        System.out.println("第一个元素: " + map.firstKey());
        System.out.println("最后一个元素: " + map.lastKey());
        
        // 获取子Map
        System.out.println("a到c之间的元素:");
        map.subMap("a", "d").forEach((key, value) -> 
            System.out.println(key + " = " + value));
    }
}
```

### ConcurrentSkipListSet

```java
import java.util.concurrent.ConcurrentSkipListSet;

public class ConcurrentSkipListSetExample {
    
    public static void main(String[] args) {
        ConcurrentSkipListSet<String> set = new ConcurrentSkipListSet<>();
        
        // 添加元素（自动排序）
        set.add("zebra");
        set.add("apple");
        set.add("banana");
        set.add("cat");
        
        System.out.println("排序后的Set:");
        set.forEach(System.out::println);
        
        // 获取第一个和最后一个元素
        System.out.println("第一个元素: " + set.first());
        System.out.println("最后一个元素: " + set.last());
        
        // 获取子Set
        System.out.println("a到c之间的元素:");
        set.subSet("a", "d").forEach(System.out::println);
    }
}
```

## 性能比较

### 不同容器的性能特点

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class ContainerPerformanceComparison {
    
    public static void main(String[] args) {
        // HashMap vs ConcurrentHashMap
        System.out.println("=== HashMap vs ConcurrentHashMap ===");
        
        // HashMap（非线程安全）
        Map<String, Integer> hashMap = new HashMap<>();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            hashMap.put("key" + i, i);
        }
        System.out.println("HashMap写入时间: " + (System.currentTimeMillis() - start) + "ms");
        
        // ConcurrentHashMap（线程安全）
        Map<String, Integer> concurrentHashMap = new ConcurrentHashMap<>();
        start = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            concurrentHashMap.put("key" + i, i);
        }
        System.out.println("ConcurrentHashMap写入时间: " + (System.currentTimeMillis() - start) + "ms");
        
        // ArrayList vs CopyOnWriteArrayList
        System.out.println("\n=== ArrayList vs CopyOnWriteArrayList ===");
        
        // ArrayList（非线程安全）
        List<String> arrayList = new ArrayList<>();
        start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            arrayList.add("item" + i);
        }
        System.out.println("ArrayList写入时间: " + (System.currentTimeMillis() - start) + "ms");
        
        // CopyOnWriteArrayList（线程安全）
        List<String> copyOnWriteArrayList = new CopyOnWriteArrayList<>();
        start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            copyOnWriteArrayList.add("item" + i);
        }
        System.out.println("CopyOnWriteArrayList写入时间: " + (System.currentTimeMillis() - start) + "ms");
    }
}
```

## 最佳实践

### 1. 选择合适的容器

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class ContainerSelectionGuide {
    
    // 高并发读写 - 使用ConcurrentHashMap
    public static <K, V> Map<K, V> createHighConcurrencyMap() {
        return new ConcurrentHashMap<>();
    }
    
    // 读多写少 - 使用CopyOnWriteArrayList
    public static <T> List<T> createReadHeavyList() {
        return new CopyOnWriteArrayList<>();
    }
    
    // 生产者消费者 - 使用BlockingQueue
    public static <T> BlockingQueue<T> createProducerConsumerQueue() {
        return new LinkedBlockingQueue<>();
    }
    
    // 需要排序 - 使用ConcurrentSkipListMap
    public static <K extends Comparable<K>, V> Map<K, V> createSortedMap() {
        return new ConcurrentSkipListMap<>();
    }
}
```

### 2. 避免常见陷阱

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class CommonPitfalls {
    
    // 错误：在迭代时修改集合
    public static void wrongIteration() {
        List<String> list = new CopyOnWriteArrayList<>();
        list.add("a");
        list.add("b");
        list.add("c");
        
        // 这样是安全的，因为CopyOnWriteArrayList在迭代时创建副本
        for (String item : list) {
            list.add("new"); // 不会影响当前迭代
        }
    }
    
    // 正确：使用原子操作
    public static void correctAtomicOperation() {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // 使用原子操作而不是检查然后设置
        map.computeIfAbsent("key", k -> 1);
        
        // 而不是
        // if (!map.containsKey("key")) {
        //     map.put("key", 1);
        // }
    }
}
```

## 面试题

### 1. ConcurrentHashMap和Hashtable有什么区别？

**答案：**
- Hashtable使用synchronized关键字，锁粒度大，性能较差
- ConcurrentHashMap使用分段锁，锁粒度小，性能更好
- Hashtable不允许null键值，ConcurrentHashMap允许null值
- ConcurrentHashMap的迭代器是弱一致性的

### 2. CopyOnWriteArrayList适用于什么场景？

**答案：**
- 读多写少的场景
- 监听器列表等需要频繁遍历但很少修改的场景
- 写操作会创建新副本，内存开销较大
- 迭代器不会抛出ConcurrentModificationException

### 3. BlockingQueue的几种实现有什么区别？

**答案：**
- ArrayBlockingQueue：有界队列，基于数组
- LinkedBlockingQueue：有界或无界队列，基于链表
- PriorityBlockingQueue：无界优先级队列
- SynchronousQueue：不存储元素的阻塞队列

### 4. 如何选择合适的并发容器？

**答案：**
- 高并发读写：ConcurrentHashMap
- 读多写少：CopyOnWriteArrayList
- 生产者消费者：BlockingQueue
- 需要排序：ConcurrentSkipListMap
- 简单同步：Collections.synchronizedXXX()

### 5. ConcurrentHashMap的size()方法是如何实现的？

**答案：**
- 遍历所有段，累加每个段的元素数量
- 由于并发修改，size()返回的是近似值
- 如果需要精确值，可以使用mappingCount()方法
- 在高并发环境下，size()的性能可能不如预期
