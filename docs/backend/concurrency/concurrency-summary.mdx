---
sidebar_position: 1
title: "Java并发编程总结"
description: "Java并发编程核心概念与面试重点总结"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# Java并发编程总结

并发编程是Java后端开发中的核心技术，掌握并发编程对于构建高性能、高可用的系统至关重要。本文档总结了Java并发编程的核心概念和面试重点。

## 并发编程核心概念

### 1. 进程与线程
- **进程**：操作系统分配资源的基本单位
- **线程**：CPU调度的基本单位，共享进程资源
- **线程安全**：多线程环境下程序的正确性

### 2. 并发与并行
- **并发(Concurrency)**：多个任务交替执行
- **并行(Parallelism)**：多个任务同时执行
- **区别**：并发关注任务的组织，并行关注任务的执行

## Java并发编程体系

### 线程基础
```
Thread
├── 创建方式
│   ├── 继承Thread类
│   ├── 实现Runnable接口
│   └── 实现Callable接口
├── 生命周期
│   ├── NEW (新建)
│   ├── RUNNABLE (可运行)
│   ├── BLOCKED (阻塞)
│   ├── WAITING (等待)
│   ├── TIMED_WAITING (超时等待)
│   └── TERMINATED (终止)
└── 线程控制
    ├── start() - 启动线程
    ├── join() - 等待线程结束
    ├── interrupt() - 中断线程
    └── yield() - 让出CPU
```

### 线程安全机制
```
线程安全
├── 原子性 (Atomicity)
│   ├── synchronized关键字
│   ├── volatile关键字
│   └── 原子类 (AtomicXXX)
├── 可见性 (Visibility)
│   ├── volatile关键字
│   ├── synchronized关键字
│   └── final关键字
└── 有序性 (Ordering)
    ├── happens-before原则
    ├── volatile关键字
    └── synchronized关键字
```

### 锁机制
```
锁机制
├── 内置锁 (synchronized)
│   ├── 对象锁
│   ├── 类锁
│   └── 方法锁
├── 显式锁 (Lock)
│   ├── ReentrantLock (可重入锁)
│   ├── ReadWriteLock (读写锁)
│   └── StampedLock (邮戳锁)
└── 分布式锁
    ├── Redis分布式锁
    ├── Zookeeper分布式锁
    └── 数据库分布式锁
```

### 并发工具类
```
并发工具
├── 线程池 (ThreadPoolExecutor)
│   ├── FixedThreadPool
│   ├── CachedThreadPool
│   ├── ScheduledThreadPool
│   └── SingleThreadExecutor
├── 同步工具
│   ├── CountDownLatch (倒计时门闩)
│   ├── CyclicBarrier (循环屏障)
│   ├── Semaphore (信号量)
│   └── Phaser (移相器)
└── 并发集合
    ├── ConcurrentHashMap
    ├── CopyOnWriteArrayList
    ├── BlockingQueue
    └── ConcurrentLinkedQueue
```

## 核心面试重点

### 1. 线程安全三大问题
- **原子性**：操作不可分割，要么全部执行，要么全部不执行
- **可见性**：一个线程对共享变量的修改，其他线程能够立即看到
- **有序性**：程序执行的顺序符合代码的先后顺序

### 2. synchronized关键字
- **作用**：保证原子性、可见性和有序性
- **原理**：基于对象头的Mark Word
- **锁升级**：无锁 → 偏向锁 → 轻量级锁 → 重量级锁
- **使用场景**：方法、代码块、静态方法

### 3. volatile关键字
- **作用**：保证可见性和有序性，不保证原子性
- **原理**：内存屏障和禁止指令重排
- **使用场景**：单线程写多线程读的场景

### 4. 线程池
- **核心参数**：corePoolSize、maximumPoolSize、keepAliveTime、workQueue、threadFactory、handler
- **工作原理**：线程复用，避免频繁创建销毁
- **拒绝策略**：AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy

### 5. 死锁问题
- **产生条件**：互斥、占有且等待、不可剥夺、循环等待
- **预防策略**：破坏四个条件中的任意一个
- **检测方法**：jstack、ThreadMXBean

## 常见并发问题

### 1. 竞态条件
- **定义**：多个线程访问共享数据时，最终结果依赖于线程的执行时序
- **解决方案**：使用同步机制

### 2. 内存可见性
- **问题**：一个线程的修改对其他线程不可见
- **解决方案**：使用volatile或synchronized

### 3. 指令重排
- **问题**：编译器或处理器优化导致指令执行顺序改变
- **解决方案**：使用volatile或synchronized

### 4. 线程饥饿
- **问题**：某些线程长时间得不到执行
- **解决方案**：使用公平锁或调整线程优先级

## 性能优化

### 1. 减少锁竞争
- **锁分离**：将大锁拆分为多个小锁
- **锁粗化**：将多个小锁合并为大锁
- **无锁编程**：使用CAS操作

### 2. 线程池优化
- **合理设置线程数**：CPU密集型 vs IO密集型
- **选择合适的队列**：有界队列 vs 无界队列
- **监控线程池状态**：活跃线程数、队列大小

### 3. 内存优化
- **减少对象创建**：对象池、缓存
- **避免内存泄漏**：及时释放资源
- **合理使用缓存**：本地缓存 vs 分布式缓存

## 面试常见问题

### 基础概念
1. **线程和进程的区别**
2. **synchronized和volatile的区别**
3. **线程的生命周期**
4. **死锁的产生和预防**

### 深入原理
1. **synchronized的实现原理**
2. **volatile的实现原理**
3. **线程池的工作原理**
4. **CAS操作的原理**

### 实际应用
1. **如何设计线程安全的类**
2. **如何选择合适的锁机制**
3. **如何优化并发性能**
4. **如何处理并发异常**

## 学习建议

### 理论基础
1. **理解并发编程的基本概念**
2. **掌握Java内存模型(JMM)**
3. **学习各种同步机制的原理**
4. **了解性能优化的方法**

### 实践能力
1. **编写多线程程序**
2. **调试并发问题**
3. **性能测试和优化**
4. **阅读并发相关的源码**

### 扩展知识
1. **分布式并发**：分布式锁、分布式事务
2. **异步编程**：CompletableFuture、响应式编程
3. **并发框架**：Disruptor、Fork/Join框架

通过系统学习Java并发编程，你将能够：
- 设计线程安全的程序
- 解决复杂的并发问题
- 优化程序的并发性能
- 构建高并发的系统架构 