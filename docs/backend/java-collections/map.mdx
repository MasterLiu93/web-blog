---
sidebar_position: 2
title: "Map集合"
description: "Java Map接口及其实现类"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# Map集合

## Map接口概述

Map是Java集合框架中用于存储键值对的数据结构，它不继承自Collection接口，是一个独立的接口。

### Map接口特点

```java
// Map接口的主要特点
1. 键值对存储：每个元素包含一个键和一个值
2. 键唯一性：键不能重复，值可以重复
3. 无序性：大多数实现类不保证元素的顺序
4. 可修改：支持增删改查操作
```

### Map接口方法

```java
// Map接口的核心方法
public interface Map<K,V> {
    // 基本操作
    V put(K key, V value);                    // 添加或更新键值对
    V get(Object key);                         // 根据键获取值
    V remove(Object key);                      // 根据键删除键值对
    boolean containsKey(Object key);           // 是否包含指定键
    boolean containsValue(Object value);       // 是否包含指定值
    
    // 集合操作
    Set<K> keySet();                          // 获取所有键的集合
    Collection<V> values();                   // 获取所有值的集合
    Set<Map.Entry<K,V>> entrySet();          // 获取所有键值对的集合
    
    // 批量操作
    void putAll(Map<? extends K,? extends V> m); // 添加另一个Map的所有元素
    void clear();                             // 清空Map
    
    // 查询操作
    int size();                               // 获取元素个数
    boolean isEmpty();                        // 判断是否为空
}
```

## HashMap

### HashMap概述

HashMap是基于哈希表实现的Map，是Java中最常用的Map实现类。

```java
// HashMap的特点
1. 基于哈希表实现
2. 无序性：不保证元素的顺序
3. 允许null键和null值
4. 线程不安全
5. 查找、插入、删除性能好 O(1)
```

### HashMap源码分析

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
    
    // 默认初始容量
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
    
    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 << 30;
    
    // 默认负载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    
    // 链表转红黑树的阈值
    static final int TREEIFY_THRESHOLD = 8;
    
    // 红黑树转链表的阈值
    static final int UNTREEIFY_THRESHOLD = 6;
    
    // 最小树化容量
    static final int MIN_TREEIFY_CAPACITY = 64;
    
    // 哈希表
    transient Node<K,V>[] table;
    
    // 键值对集合
    transient Set<Map.Entry<K,V>> entrySet;
    
    // 元素个数
    transient int size;
    
    // 修改次数
    transient int modCount;
    
    // 阈值
    int threshold;
    
    // 负载因子
    final float loadFactor;
}
```

### HashMap节点结构

```java
// 链表节点
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
    
    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
    
    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + "=" + value; }
    
    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }
    
    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    
    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
```

### HashMap哈希算法

```java
// 哈希算法
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// 计算数组索引
static int indexFor(int h, int length) {
    return h & (length - 1);
}
```

### HashMap使用示例

```java
// 基本使用
public class HashMapExample {
    public static void main(String[] args) {
        // 创建HashMap
        Map<String, Integer> map = new HashMap<>();
        
        // 添加元素
        map.put("Java", 1);
        map.put("Python", 2);
        map.put("C++", 3);
        
        // 获取元素
        Integer value = map.get("Java");
        System.out.println("Java的值: " + value);
        
        // 检查键是否存在
        boolean containsKey = map.containsKey("Java");
        System.out.println("是否包含Java: " + containsKey);
        
        // 删除元素
        map.remove("C++");
        
        // 遍历
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 遍历键
        for (String key : map.keySet()) {
            System.out.println("键: " + key);
        }
        
        // 遍历值
        for (Integer val : map.values()) {
            System.out.println("值: " + val);
        }
    }
}
```

### HashMap性能分析

```java
// 性能测试
public class HashMapPerformance {
    
    // 插入性能测试
    public void putPerformance() {
        Map<String, Integer> map = new HashMap<>();
        long start = System.currentTimeMillis();
        
        for (int i = 0; i < 100000; i++) {
            map.put("key" + i, i);
        }
        
        long end = System.currentTimeMillis();
        System.out.println("插入100000个元素耗时: " + (end - start) + "ms");
    }
    
    // 查找性能测试
    public void getPerformance() {
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < 100000; i++) {
            map.put("key" + i, i);
        }
        
        long start = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            map.get("key" + i);
        }
        long end = System.currentTimeMillis();
        System.out.println("查找100000次耗时: " + (end - start) + "ms");
    }
}
```

## LinkedHashMap

### LinkedHashMap概述

LinkedHashMap是HashMap的子类，它在HashMap的基础上维护了一个双向链表，保证了元素的插入顺序。

```java
// LinkedHashMap的特点
1. 继承自HashMap
2. 维护插入顺序或访问顺序
3. 可以按访问顺序排序
4. 线程不安全
5. 性能略低于HashMap
```

### LinkedHashMap源码分析

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V> {
    
    // 双向链表节点
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
    
    // 头节点
    transient LinkedHashMap.Entry<K,V> head;
    
    // 尾节点
    transient LinkedHashMap.Entry<K,V> tail;
    
    // 是否按访问顺序排序
    final boolean accessOrder;
    
    // 构造方法
    public LinkedHashMap() {
        super();
        accessOrder = false;
    }
    
    public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
}
```

### LinkedHashMap使用示例

```java
// LinkedHashMap基本使用
public class LinkedHashMapExample {
    public static void main(String[] args) {
        // 按插入顺序排序
        Map<String, Integer> insertOrderMap = new LinkedHashMap<>();
        insertOrderMap.put("Java", 1);
        insertOrderMap.put("Python", 2);
        insertOrderMap.put("C++", 3);
        
        System.out.println("按插入顺序:");
        for (Map.Entry<String, Integer> entry : insertOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 按访问顺序排序
        Map<String, Integer> accessOrderMap = new LinkedHashMap<>(16, 0.75f, true);
        accessOrderMap.put("Java", 1);
        accessOrderMap.put("Python", 2);
        accessOrderMap.put("C++", 3);
        
        // 访问元素，会改变顺序
        accessOrderMap.get("Java");
        accessOrderMap.get("Python");
        
        System.out.println("按访问顺序:");
        for (Map.Entry<String, Integer> entry : accessOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

## TreeMap

### TreeMap概述

TreeMap是基于红黑树实现的Map，它保证了元素的有序性。

```java
// TreeMap的特点
1. 基于红黑树实现
2. 有序性：按键的自然顺序或自定义顺序排序
3. 不允许null键，允许null值
4. 线程不安全
5. 查找、插入、删除性能 O(log n)
```

### TreeMap源码分析

```java
public class TreeMap<K,V> extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable {
    
    // 比较器
    private final Comparator<? super K> comparator;
    
    // 根节点
    private transient Entry<K,V> root;
    
    // 元素个数
    private transient int size = 0;
    
    // 修改次数
    private transient int modCount = 0;
    
    // 红黑树节点
    static final class Entry<K,V> implements Map.Entry<K,V> {
        K key;
        V value;
        Entry<K,V> left;
        Entry<K,V> right;
        Entry<K,V> parent;
        boolean color = BLACK;
        
        Entry(K key, V value, Entry<K,V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }
    }
}
```

### TreeMap使用示例

```java
// TreeMap基本使用
public class TreeMapExample {
    public static void main(String[] args) {
        // 自然顺序排序
        Map<String, Integer> naturalOrderMap = new TreeMap<>();
        naturalOrderMap.put("Java", 1);
        naturalOrderMap.put("Python", 2);
        naturalOrderMap.put("C++", 3);
        
        System.out.println("自然顺序:");
        for (Map.Entry<String, Integer> entry : naturalOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 自定义比较器
        Map<String, Integer> customOrderMap = new TreeMap<>((s1, s2) -> s2.compareTo(s1));
        customOrderMap.put("Java", 1);
        customOrderMap.put("Python", 2);
        customOrderMap.put("C++", 3);
        
        System.out.println("自定义顺序:");
        for (Map.Entry<String, Integer> entry : customOrderMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 导航方法
        TreeMap<String, Integer> treeMap = new TreeMap<>(naturalOrderMap);
        
        // 获取第一个元素
        Map.Entry<String, Integer> first = treeMap.firstEntry();
        System.out.println("第一个元素: " + first.getKey() + "=" + first.getValue());
        
        // 获取最后一个元素
        Map.Entry<String, Integer> last = treeMap.lastEntry();
        System.out.println("最后一个元素: " + last.getKey() + "=" + last.getValue());
        
        // 获取小于指定键的最大键值对
        Map.Entry<String, Integer> lower = treeMap.lowerEntry("Python");
        System.out.println("小于Python的最大元素: " + lower.getKey() + "=" + lower.getValue());
        
        // 获取大于指定键的最小键值对
        Map.Entry<String, Integer> higher = treeMap.higherEntry("Java");
        System.out.println("大于Java的最小元素: " + higher.getKey() + "=" + higher.getValue());
    }
}
```

## ConcurrentHashMap

### ConcurrentHashMap概述

ConcurrentHashMap是线程安全的HashMap实现，适用于多线程环境。

```java
// ConcurrentHashMap的特点
1. 线程安全
2. 分段锁机制
3. 不允许null键和null值
4. 性能优于Hashtable
5. 适用于高并发场景
```

### ConcurrentHashMap源码分析

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {
    
    // 段数组
    final Segment<K,V>[] segments;
    
    // 段的数量
    static final int DEFAULT_CONCURRENCY_LEVEL = 16;
    
    // 段类
    static final class Segment<K,V> extends ReentrantLock implements Serializable {
        transient volatile HashEntry<K,V>[] table;
        transient int count;
        transient int modCount;
        transient int threshold;
        final float loadFactor;
    }
    
    // 哈希表节点
    static final class HashEntry<K,V> {
        final K key;
        final int hash;
        volatile V value;
        final HashEntry<K,V> next;
        
        HashEntry(K key, int hash, HashEntry<K,V> next, V value) {
            this.key = key;
            this.hash = hash;
            this.next = next;
            this.value = value;
        }
    }
}
```

### ConcurrentHashMap使用示例

```java
// ConcurrentHashMap基本使用
public class ConcurrentHashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new ConcurrentHashMap<>();
        
        // 多线程安全操作
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                map.put("Thread1-" + i, i);
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                map.put("Thread2-" + i, i);
            }
        });
        
        t1.start();
        t2.start();
        
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("最终大小: " + map.size());
        
        // 原子操作
        map.putIfAbsent("key", 1);  // 如果键不存在则添加
        map.replace("key", 1, 2);   // 如果值等于1则替换为2
        map.remove("key", 2);       // 如果值等于2则删除
    }
}
```

## 其他Map实现

### Hashtable

```java
// Hashtable - 线程安全的Map（已过时）
public class HashtableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new Hashtable<>();
        
        // 基本操作
        map.put("Java", 1);
        map.put("Python", 2);
        
        // 不允许null键和null值
        // map.put(null, 1);  // 抛出NullPointerException
        // map.put("key", null);  // 抛出NullPointerException
        
        System.out.println(map);
    }
}
```

### WeakHashMap

```java
// WeakHashMap - 弱引用Map
public class WeakHashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new WeakHashMap<>();
        
        String key1 = new String("key1");
        String key2 = new String("key2");
        
        map.put(key1, 1);
        map.put(key2, 2);
        
        System.out.println("GC前: " + map.size()); // 2
        
        // 释放强引用
        key1 = null;
        key2 = null;
        
        // 触发GC
        System.gc();
        
        System.out.println("GC后: " + map.size()); // 0
    }
}
```

## Map使用最佳实践

### 选择合适的Map实现

```java
// Map选择指南
public class MapSelectionGuide {
    
    // 场景1：一般用途
    public void generalPurposeScenario() {
        `Map<String, Integer> map = new HashMap<>();` // 推荐
    }
    
    // 场景2：需要保持插入顺序
    public void insertionOrderScenario() {
        `Map<String, Integer> map = new LinkedHashMap<>();` // 推荐
    }
    
    // 场景3：需要按键排序
    public void sortedScenario() {
        `Map<String, Integer> map = new TreeMap<>();` // 推荐
    }
    
    // 场景4：多线程环境
    public void threadSafeScenario() {
        `Map<String, Integer> map = new ConcurrentHashMap<>();` // 推荐
    }
    
    // 场景5：缓存场景
    public void cacheScenario() {
        `Map<String, Integer> map = new WeakHashMap<>();` // 推荐
    }
}
```

### 性能优化技巧

```java
// Map性能优化
public class MapOptimization {
    
    // 1. 预分配容量
    public void preAllocateCapacity() {
        `Map<String, Integer> map = new HashMap<>(1000);` // 预分配1000个容量
    }
    
    // 2. 选择合适的负载因子
    public void loadFactorOptimization() {
        // 如果内存充足，可以降低负载因子提高性能
        `Map<String, Integer> map = new HashMap<>(16, 0.5f);`
    }
    
    // 3. 使用合适的键类型
    public void keyTypeOptimization() {
        // 使用不可变对象作为键
        `Map<String, Integer> map = new HashMap<>();` // 推荐
        // `Map<StringBuilder, Integer> map = new HashMap<>();` // 不推荐
    }
    
    // 4. 批量操作
    public void batchOperation() {
        Map<String, Integer> map1 = new HashMap<>();
        Map<String, Integer> map2 = new HashMap<>();
        
        // 批量添加
        map1.putAll(map2);
        
        // 批量删除
        map1.keySet().removeAll(map2.keySet());
    }
}
```

## 面试题

### 1. HashMap和Hashtable的区别？

**HashMap**：
- 线程不安全
- 允许null键和null值
- 性能较好
- 继承自AbstractMap

**Hashtable**：
- 线程安全（同步）
- 不允许null键和null值
- 性能较差
- 继承自Dictionary

### 2. HashMap的工作原理？

1. **哈希算法**：计算键的哈希值
2. **索引计算**：hash & (length - 1)
3. **冲突处理**：链表或红黑树
4. **扩容机制**：负载因子超过阈值时扩容

### 3. HashMap的扩容机制？

1. **触发条件**：size >= threshold
2. **扩容大小**：新容量 = 旧容量 * 2
3. **重新哈希**：重新计算所有元素的索引
4. **性能影响**：扩容时性能下降

### 4. ConcurrentHashMap的线程安全机制？

1. **分段锁**：将整个Map分成多个段
2. **段内同步**：每个段使用ReentrantLock
3. **读不加锁**：读取时不需要同步
4. **写加锁**：写入时只锁定对应的段

### 5. TreeMap和HashMap的区别？

**TreeMap**：
- 基于红黑树实现
- 有序性
- 性能 O(log n)
- 不允许null键

**HashMap**：
- 基于哈希表实现
- 无序性
- 性能 O(1)
- 允许null键

### 6. LinkedHashMap如何保持顺序？

1. **双向链表**：维护一个双向链表
2. **插入顺序**：默认按插入顺序排序
3. **访问顺序**：可以按访问顺序排序
4. **LRU缓存**：可以实现LRU缓存

### 7. Map的遍历方式有哪些？

```java
// 1. 遍历键值对
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// 2. 遍历键
for (String key : map.keySet()) {
    System.out.println("键: " + key);
}

// 3. 遍历值
for (Integer value : map.values()) {
    System.out.println("值: " + value);
}

// 4. 使用迭代器
Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<String, Integer> entry = iterator.next();
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```

### 8. 如何选择合适的Map实现？

- **一般用途**：HashMap
- **需要保持顺序**：LinkedHashMap
- **需要排序**：TreeMap
- **多线程环境**：ConcurrentHashMap
- **缓存场景**：WeakHashMap

### 9. HashMap的冲突解决方法？

1. **链表法**：冲突的元素形成链表
2. **红黑树**：链表长度超过8时转为红黑树
3. **开放寻址法**：其他实现可能使用

### 10. Map的性能优化技巧？

1. **预分配容量**：避免频繁扩容
2. **合适的负载因子**：平衡空间和时间
3. **合适的键类型**：使用不可变对象
4. **批量操作**：使用putAll等方法 