---
sidebar_position: 1
title: "设计模式总结"
description: "设计模式核心概念与面试重点总结"
authors: [Laby]
last_update:
  date: 2025-08-07
  author: Laby
---

# 设计模式总结

设计模式是软件开发中的重要概念，提供了解决常见设计问题的标准方案。本文档总结了设计模式的核心概念和面试重点。

## 设计模式分类

### 创建型模式
```
创建型模式
├── 单例模式 (Singleton)
│   ├── 确保一个类只有一个实例
│   ├── 全局访问点
│   └── 延迟初始化
├── 工厂方法模式 (Factory Method)
│   ├── 定义创建对象的接口
│   ├── 让子类决定实例化类
│   └── 封装对象创建过程
├── 抽象工厂模式 (Abstract Factory)
│   ├── 创建相关对象家族
│   ├── 不依赖具体类
│   └── 产品族概念
├── 建造者模式 (Builder)
│   ├── 分步骤构建复杂对象
│   ├── 链式调用
│   └── 参数校验
└── 原型模式 (Prototype)
    ├── 通过克隆创建对象
    ├── 避免重复初始化
    └── 深拷贝vs浅拷贝
```

### 结构型模式
```
结构型模式
├── 适配器模式 (Adapter)
│   ├── 接口适配
│   ├── 类适配器
│   └── 对象适配器
├── 桥接模式 (Bridge)
│   ├── 抽象与实现分离
│   ├── 多维度变化
│   └── 避免继承爆炸
├── 组合模式 (Composite)
│   ├── 树形结构
│   ├── 统一接口
│   └── 递归处理
├── 装饰器模式 (Decorator)
│   ├── 动态扩展功能
│   ├── 不改变原类
│   └── 组合优于继承
├── 外观模式 (Facade)
│   ├── 简化接口
│   ├── 降低耦合
│   └── 统一入口
├── 享元模式 (Flyweight)
│   ├── 共享细粒度对象
│   ├── 减少内存占用
│   └── 内部状态vs外部状态
└── 代理模式 (Proxy)
    ├── 控制对象访问
    ├── 虚拟代理
    ├── 保护代理
    └── 远程代理
```

### 行为型模式
```
行为型模式
├── 责任链模式 (Chain of Responsibility)
│   ├── 请求处理链
│   ├── 动态组合
│   └── 避免耦合
├── 命令模式 (Command)
│   ├── 封装请求
│   ├── 支持撤销
│   └── 宏命令
├── 解释器模式 (Interpreter)
│   ├── 语法树
│   ├── 表达式求值
│   └── 领域特定语言
├── 迭代器模式 (Iterator)
│   ├── 统一遍历接口
│   ├── 内部迭代器
│   └── 外部迭代器
├── 中介者模式 (Mediator)
│   ├── 集中控制
│   ├── 减少耦合
│   └── 协调对象
├── 备忘录模式 (Memento)
│   ├── 状态保存
│   ├── 撤销功能
│   └── 历史记录
├── 观察者模式 (Observer)
│   ├── 一对多依赖
│   ├── 事件通知
│   └── 松耦合
├── 状态模式 (State)
│   ├── 状态转换
│   ├── 行为变化
│   └── 消除条件分支
├── 策略模式 (Strategy)
│   ├── 算法族
│   ├── 可互换
│   └── 运行时选择
├── 模板方法模式 (Template Method)
│   ├── 算法骨架
│   ├── 钩子方法
│   └── 子类定制
└── 访问者模式 (Visitor)
    ├── 数据结构分离
    ├── 操作扩展
    └── 双重分发
```

## 核心面试重点

### 1. 创建型模式
- **单例模式**：线程安全、延迟加载、枚举实现
- **工厂模式**：简单工厂、工厂方法、抽象工厂的区别
- **建造者模式**：链式调用、参数校验、不可变对象
- **原型模式**：深拷贝、浅拷贝、Cloneable接口

### 2. 结构型模式
- **适配器模式**：类适配器vs对象适配器
- **装饰器模式**：动态扩展、不改变原类
- **代理模式**：静态代理vs动态代理
- **组合模式**：树形结构、统一接口

### 3. 行为型模式
- **观察者模式**：事件驱动、松耦合
- **策略模式**：算法族、可互换
- **责任链模式**：请求处理链、动态组合
- **状态模式**：状态转换、消除条件分支

## 设计原则

### SOLID原则
```
SOLID原则
├── 单一职责原则 (SRP)
│   ├── 一个类只有一个变化原因
│   ├── 高内聚
│   └── 低耦合
├── 开闭原则 (OCP)
│   ├── 对扩展开放
│   ├── 对修改关闭
│   └── 抽象化
├── 里氏替换原则 (LSP)
│   ├── 子类可替换父类
│   ├── 行为一致性
│   └── 契约设计
├── 接口隔离原则 (ISP)
│   ├── 客户端不依赖不需要的接口
│   ├── 接口细化
│   └── 避免胖接口
└── 依赖倒置原则 (DIP)
    ├── 依赖抽象
    ├── 不依赖具体
    └── 控制反转
```

### 其他原则
```
其他原则
├── 迪米特法则 (LoD)
│   ├── 最少知识原则
│   ├── 降低耦合
│   └── 封装变化
├── 组合优于继承
│   ├── 灵活性
│   ├── 可扩展性
│   └── 避免继承爆炸
├── 封装变化
│   ├── 识别变化点
│   ├── 抽象变化
│   └── 隔离变化
└── 针对接口编程
    ├── 依赖抽象
    ├── 多态性
    └── 可扩展性
```

## 实际应用场景

### 框架中的应用
```
框架应用
├── Spring框架
│   ├── IoC容器 - 工厂模式
│   ├── AOP - 代理模式
│   ├── 事件机制 - 观察者模式
│   └── 模板方法 - JdbcTemplate
├── Java集合框架
│   ├── Iterator - 迭代器模式
│   ├── Collections - 装饰器模式
│   └── 组合模式 - 树形结构
├── JDK内置模式
│   ├── Runtime - 单例模式
│   ├── Calendar - 工厂模式
│   ├── InputStream - 装饰器模式
│   └── ThreadPoolExecutor - 模板方法
└── 第三方框架
    ├── MyBatis - 建造者模式
    ├── Netty - 责任链模式
    └── Guava - 策略模式
```

### 业务场景应用
```
业务应用
├── 用户权限系统
│   ├── 责任链模式 - 权限验证
│   ├── 策略模式 - 不同验证策略
│   └── 代理模式 - 权限控制
├── 订单系统
│   ├── 状态模式 - 订单状态
│   ├── 观察者模式 - 订单事件
│   └── 命令模式 - 订单操作
├── 缓存系统
│   ├── 代理模式 - 缓存代理
│   ├── 装饰器模式 - 缓存装饰
│   └── 享元模式 - 对象复用
└── 日志系统
    ├── 责任链模式 - 日志处理链
    ├── 策略模式 - 不同日志策略
    └── 观察者模式 - 日志事件
```

## 性能考虑

### 模式选择
- **创建型模式**：对象创建开销、内存占用
- **结构型模式**：对象关系复杂度、内存布局
- **行为型模式**：方法调用开销、状态管理

### 优化策略
- **对象池**：减少对象创建开销
- **缓存机制**：避免重复计算
- **延迟加载**：按需创建对象
- **享元模式**：共享不可变对象

## 常见面试问题

### 基础概念
1. **设计模式的分类和特点**
2. **SOLID原则的含义**
3. **设计模式vs设计原则**
4. **模式的选择标准**

### 具体模式
1. **单例模式的线程安全实现**
2. **工厂模式和抽象工厂的区别**
3. **装饰器模式和代理模式的区别**
4. **观察者模式的实现方式**

### 实际应用
1. **如何在项目中应用设计模式**
2. **如何避免过度设计**
3. **如何重构现有代码使用模式**
4. **如何评估模式的效果**

### 性能优化
1. **设计模式对性能的影响**
2. **如何优化模式实现**
3. **模式组合的性能考虑**
4. **内存和CPU使用优化**

## 学习建议

### 理论基础
1. **理解设计模式的核心思想**
2. **掌握SOLID设计原则**
3. **学习模式之间的关系**
4. **了解反模式的概念**

### 实践能力
1. **识别代码中的模式应用**
2. **在项目中应用设计模式**
3. **重构代码使用模式**
4. **评估模式的效果**

### 扩展知识
1. **架构模式**
2. **企业级模式**
3. **并发模式**
4. **函数式编程模式**

通过系统学习设计模式，你将能够：
- 编写高质量、可维护的代码
- 设计灵活、可扩展的系统架构
- 解决复杂的设计问题
- 提高代码的可读性和可测试性 